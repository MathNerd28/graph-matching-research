package edu.rit.cs.graph_matching;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Random;
import java.util.Set;

/**
 * An implementation of the Dani-Hayes randomized algorithm for generating
 * matchings on regular graphs: https://doi.org/10.1137/1.9781611978322.166
 * <p>
 * At any time, the algorithm can be terminated by interrupting its thread. This
 * will not throw an {@link InterruptedException}, nor will the algorithm clear
 * the interruption. The algorithm will immediately return the matching it has
 * found thus far regardless of its size.
 */
public class DaniHayesAlgorithm {
  /** The input graph */
  private final Graph graph;

  /** The random number generator used by the algorithm */
  private final Random random;

  /**
   * Tracks the matching edge of each vertex:
   * <ul>
   * <li>If matches[v] = w, then matches[w] = v, and {v, w} is in the current
   * matching.</li>
   * <li>If matches[v] = -1, then v is an unmatched vertex.</li>
   * </ul>
   */
  private final int[] matches;

  /**
   * Tracks the non-matching edge of each vertex in the ALP:
   * <ul>
   * <li>If adjacents[v] = w, then adjacents[w] = v. This does not necessarily
   * indicate that v and/or w are in the ALP.</li>
   * <li>If adjacents[v] = -1, then v doesn't have a non-matching edge in the
   * ALP.</li>
   * </ul>
   */
  private final int[] adjacents;

  /**
   * If inPath[v] == pathId, then vertex v is in the current ALP.
   */
  private final int[] inPath;

  /**
   * Tracks the vertices that have yet to be added to the matching.
   */
  private final IntHashSet unmatched;

  /** The start vertex of the current ALP */
  private int start;

  /** The head vertex of the current ALP */
  private int head;

  /** The id of the current ALP */
  private int pathId;

  /**
   * Initialize the algorithm with a particular input graph and a pre-seeded
   * random number generator.
   *
   * @param graph
   *   the input graph
   * @param random
   *   the random number generator to be used by the algorithm.
   */
  public DaniHayesAlgorithm(Graph graph, Random random) {
    this.graph = graph;
    this.random = random;

    this.matches = new int[graph.size()];
    this.adjacents = new int[graph.size()];
    this.inPath = new int[graph.size()];
    this.unmatched = new IntHashSet();

    Arrays.fill(matches, -1);
    for (int v = 0; v < graph.size(); v++) {
      unmatched.add(v);
    }
    clearPath();
  }

  /**
   * Initialize the algorithm with a particular input graph and a new random
   * number generator (according to {@link Random#Random()}).
   *
   * @param graph
   *   the input graph
   */
  public DaniHayesAlgorithm(Graph graph) {
    this(graph, new Random());
  }

  /**
   * A helper that generates the set of matched edges from the algorithm's
   * internal representation.
   *
   * @return the matching generated by the algorithm
   */
  private Set<Edge> convertResult() {
    Set<Edge> matching = new LinkedHashSet<>();
    for (int v = 0; v < graph.size(); v++) {
      if (matches[v] != -1) {
        matching.add(new Edge(v, matches[v]));
      }
    }
    return matching;
  }

  /**
   * Generates a matching on the input graph. The matching is guaranteed to
   * contain at least (n/2) * (1 - 1/(d+1)) - (1/log(n)) edges, but it will not
   * necessarily be a maximum matching.
   * <p>
   * This algorithm is proven to require O(n log n) runtime on d-regular graphs.
   *
   * @return the generated matching
   */
  public Set<Edge> generateMatching() {
    double averageDegree = 0;
    for (int v = 0; v < graph.size(); v++) {
      averageDegree += graph.getDegree(v);
    }
    averageDegree /= graph.size();

    double edgeCount = graph.size() / 2.0 * (1.0 - 1.0 / (Math.floor(averageDegree) + 1.0));
    buildMatching((int) Math.ceil(edgeCount));
    return convertResult();
  }

  /**
   * Generates a perfect or near-perfect matching on the input graph. The
   * algorithm will continue until it finds such a matching, even if none
   * exists. This method is not guaranteed to ever return without being
   * interrupted.
   *
   * @return a perfect or near-perfect matching, if one exists
   */
  public Set<Edge> generatePerfectMatching() {
    buildMatching(graph.size() / 2);
    return convertResult();
  }

  /**
   * Generates a matching with the specified number of edges. This method is not
   * guaranteed to ever return without being interrupted.
   *
   * @param edgeCount
   *   the number of edges in the matching in the range [0, n/2]
   * @return the generated matching
   */
  public Set<Edge> generateMatching(int edgeCount) {
    buildMatching(edgeCount);
    return convertResult();
  }

  /**
   * The BUILD_MATCHING procedure as specified in the paper. Modified only to
   * allow interruption of the algorithm by the user for the purpose of e.g.
   * timeouts, and to parameterize the minimum matching size.
   *
   * @param edgeCount
   *   the minimum number of edges in the matching
   */
  private void buildMatching(int edgeCount) {
    if (edgeCount < 0 || edgeCount > graph.size() / 2) {
      throw new IllegalArgumentException("Expected edgeCount to be in the range [0, n/2]");
    }

    // Loop could run indefinitely; allow interruption for e.g. timeouts
    int maxUnmatched = graph.size() - edgeCount * 2;
    while (unmatched.size() > maxUnmatched
        && !Thread.currentThread()
                  .isInterrupted()) {
      if (!findAugmentingPath()) {
        break;
      }

      // We have an augmenting path; augment it

      int vertex = start;
      while (true) {
        int next = getAdjacent(vertex);

        if (next == head) {
          setMatch(vertex, head);
          break;
        }

        int nextNext = getMatch(next);
        setMatch(vertex, next);
        vertex = nextNext;
      }
      unmatched.remove(start);
      unmatched.remove(head);
    }
  }

  /**
   * The FIND_AUGMENTING_PATH(M) procedure as specified in the paper. Modified
   * only to allow interruption of the algorithm by the user for the purpose of
   * e.g. timeouts.
   *
   * @return false if the algorithm was interrupted
   */
  private boolean findAugmentingPath() {
    // Loop could run indefinitely; allow interruption for e.g. timeouts
    while (!Thread.currentThread()
                  .isInterrupted()) {
      clearPath();

      start = unmatched.getRandom(random);
      head = start;
      addVertex(start);

      PathStatus status = PathStatus.ACTIVE;
      while (status == PathStatus.ACTIVE) {
        status = growPath();
      }
      if (status != PathStatus.FAIL) {
        return true;
      }
    }

    return false;
  }

  /**
   * The GROW_PATH(M, P, s, h) procedure as specified in the paper.
   *
   * @return the status of the current ALP
   */
  private PathStatus growPath() {
    // v0 = random element of N(h) \ M(h), i.e. a random neighbor of head except
    // its match
    // scale attempts by degree to handle non-regular hubs correctly
    int v0 = -1;
    int maxAttempts = 2 * graph.getDegree(head) + 10;
    int headMatch = getMatch(head);
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
      int neighbor = graph.getRandomNeighbor(head, random);
      if (neighbor != headMatch) {
        v0 = neighbor;
        break;
      }
    }
    if (v0 == -1 || v0 == start) {
      return PathStatus.FAIL;
    }

    // w0 = M(v0), i.e. the match of v0
    int w0 = getMatch(v0);
    if (w0 == -1) {
      // Case 1: v0 is unmatched, path is augmenting

      // Add {h, v0} (unmatched) to path
      addEdge(head, v0);
      addVertex(v0);

      head = v0;
      return PathStatus.DONE;
    }

    if (!hasVertex(v0)) {
      // Case 2: v0 is matched but not in path

      // Add {h, v0} (unmatched) to path
      // Add {v0, w0} (matched) to path
      addEdge(head, v0);
      addVertex(v0);
      addVertex(w0);

      head = w0;
      return PathStatus.ACTIVE;
    }

    // v0 is already in P, forming a cycle
    // Attempt local repair
    int w = w0;
    while (true) {
      int vP = getAdjacent(w);
      int wP = getMatch(vP);

      // Delete {w, vP} (unmatched) from path
      removeEdge(w);
      removeVertex(w);

      if (graph.hasEdge(vP, head) && head != wP) {
        // Shortcut (Odd Cycle)

        // Add {vP, h} (unmatched) to path
        addEdge(vP, head);

        addVertex(w0);
        head = w0;
        return PathStatus.ACTIVE;
      } else if (wP == head) {
        // Pop (Even Cycle)

        // Delete {vP, wP} (matched) from path
        removeVertex(vP);
        removeVertex(wP);

        addVertex(w0);
        head = w0;
        return PathStatus.ACTIVE;
      } else if (vP == start) {
        return PathStatus.FAIL;
      }

      // Delete {vP, wP} (matched) from path
      removeVertex(vP);

      w = wP;
    }
  }

  /**
   * The possible results of {@link DaniHayesAlgorithm#growPath()}
   */
  private enum PathStatus {
    /** The ALP is incomplete but can continue growing */
    ACTIVE,
    /** The ALP is complete and ready to be augmented */
    DONE,
    /** The ALP cannot be recovered; need to start over */
    FAIL;
  }

  /**
   * Resets the ALP to an empty state, without affecting the matching.
   */
  private void clearPath() {
    this.start = -1;
    this.head = -1;
    this.pathId++;
  }

  /**
   * Get the vertex that shares its matched edge with a vertex.
   *
   * @param vertex
   *   the vertex
   * @return the matched vertex, or -1 if nonexistent
   */
  private int getMatch(int vertex) {
    return matches[vertex];
  }

  /**
   * If the vertex shares a non-matched edge with the current ALP, returns the
   * other vertex in the edge. Otherwise, behavior is unspecified.
   *
   * @param vertex
   *   the vertex
   * @return the unmatched connected vertex in the ALP
   */
  private int getAdjacent(int vertex) {
    return adjacents[vertex];
  }

  /**
   * Adds an unmatched edge to the current ALP. Does NOT implicitly add the
   * vertices to the ALP. The edge must be unmatched, and neither vertex can
   * have another unmatched edge in the ALP.
   *
   * @param vertex1
   *   the first vertex in the edge
   * @param vertex2
   *   the second vertex in the edge
   */
  private void addEdge(int vertex1, int vertex2) {
    adjacents[vertex1] = vertex2;
    adjacents[vertex2] = vertex1;
  }

  /**
   * Removes an unmatched edge from the current ALP. Does NOT implicitly remove
   * the vertices from the ALP. The edge must be unmatched and already present
   * in the ALP.
   *
   * @param vertex
   *   one of the vertices in the edge.
   */
  private void removeEdge(int vertex) {
    int adjacent = adjacents[vertex];
    adjacents[vertex] = -1;
    adjacents[adjacent] = -1;
  }

  /**
   * Checks whether the current ALP contains a vertex.
   *
   * @param vertex
   *   the vertex
   * @return true of the ALP contains {@code vertex}
   */
  private boolean hasVertex(int vertex) {
    return inPath[vertex] == pathId;
  }

  /**
   * Adds a vertex to the current ALP.
   *
   * @param vertex
   *   the vertex to add
   */
  private void addVertex(int vertex) {
    inPath[vertex] = pathId;
  }

  /**
   * Removes a vertex from the current ALP.
   *
   * @param vertex
   *   the vertex to remove
   */
  private void removeVertex(int vertex) {
    inPath[vertex] = -1;
  }

  /**
   * Adds an edge to the matching. If either vertex was previously matched, its
   * dangling reference is left behind.
   *
   * @param vertex1
   *   the first vertex
   * @param vertex2
   *   the second vertex
   */
  private void setMatch(int vertex1, int vertex2) {
    matches[vertex1] = vertex2;
    matches[vertex2] = vertex1;
  }
}
